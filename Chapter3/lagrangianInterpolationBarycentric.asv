function [y_eval] = lagrangianInterpolationBarycentric(x,y,xeval)
%   Description of the function
%   
%   Input:
%           x        : x values of the dataset
%           y        : y values of the dataset
%           xeval    : x values for he new 
%
%   Output:
%           y_eval   : vector containing all the new computed y values that
%                      corresponds to the xeval values
    
    %% Sanity check of  the dataset
    szx = size(x); % number of x entries of the dataset
    szy = size(y); % number of y entries ot the dataset
    if szx(1) ~= szy(1)
        disp("invalid set of datapoints");
        return
    end
    
    %% Initialisation
    np = szy; % number of datapoints ######np = n
    sz = size(xeval); % number of points that need to be evaluated
    a = min(x); % lower border of the interval
    b = max(x); % upper border of the interval
    w = ones(np,1); % initialise weights
    C = 4/(b-a); % to avoid under- and overflows
    
    %% Computation
    % Compute weights w
    for j = 1:np
        for k = 1:j-1
            w(j) = w(j)*(x(j)-x(k))*C;
        end
        % important: leave k = j out!
        for k = j+1:np
            w(j) = w(j)*(x(j)-x(k))*C;
        end
    end
    w = 1./w; % ^(-1), w is done
    
    % Compute numerator and denumerator
    numer = zeros(size(xeval));
    denum = numer;
    exact = numer;
    for j = 1:np
        xdiff = xeval-x(j);  
        wx = w(j)./xdiff;
        denum = denum + wx;
        numer = numer + wx*y(j);
        exact(xdiff == 0)=j;
    end
    
    y1 = numer./denum;
    for m = 1:length(xeval)
        if 
    
    

end  

    
